# 만든 질문
<details>
<summary><strong>캐시 메모리란 무엇인지 설명해주세요</strong></summary>
<div markdown="1">
<br>
캐시 메모리란 속도가 빠른 장치와 느린 장치간의 속도 차에 따른 병목 현상을 줄이기 위한 범용 메모리입니다. CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장해두고, 다음에 해당 데이터를 사용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킵니다. 하지만 캐시메모리는 용량이 적고 비용이 비싸다는 단점이 있습니다.
</div>
</details>

<details>
<summary><strong>LinkedList와 ArrayList의 차이점에 대해 말씀해주세요</strong></summary>
<div markdown="1">
<br>
LinkedList는 노드들이 연결되어있는 형태로 각 노드는 데이터와 포인터를 갖습니다. 포인터는 다음 노드 위치의 주소값을 가집니다. 각 노드에 순차적으로 접근하여 검색하므로 검색보다는 삽입과 삭제 시에 유리합니다.  ArrayList는 중복을 허용하고 순서를 유지하며 index로 원소들을 관리합니다. 따라서 검색시에 유리합니다. 추가적으로, 객체 생성 시 크기를 지정하지 않고 동적으로 값을 추가하고 삭제합니다. 데이터를 추가할 시에, 더 큰 용량의 임시 배열을 만들어서 복제한다는 특징이 있습니다.
</div>
</details>  

<details>
<summary><strong>데이터베이스에서 Key는 왜 필요한가요?</strong></summary>
<div markdown="1">
<br>
Key를 통해서 각 레코드를 고유하게 식별하여 빠른 검색을 하는 데에 사용합니다. 또한 다른 테이블의 기본 키를 참조하여 관계를 설정하는 데에 사용합니다. 이를 통해서 테이블 간에 조인을 통한 연결과, 데이터 일관성을 유지할 수 있습니다.
</div>
</details>

<details>
<summary><strong>TCP 3-way handshake와 TCP 4-way handshake가 무엇인지 어떤 역할을 수행하는지 설명해주세요.</strong></summary>
<div markdown="1">
<br>
TCP의 3-way handshake는 TCP 통신을 이용해서 데이터를 전송하기 위해 SYN, ACK 패킷을 주고받으며 네트워크 연결을 `수립`하는 과정입니다. 이를 통해 클라이언트는 서버에게 요청을 전송할 수 는지, 서버는 클라이언트에게 응답을 전송할 수 있는 상태인지 확인합니다. 4-way handshake는 TCP의 연결을 해제하기 위해 FIN과 ACK 패킷을 주고받는 과정입니다. 클라이언트가 서버로부터 FIN을 수신받으면, 서버에게 확인했다는 응답으로 ACK를 반환합니다. 아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT를 통해 대기 후 종료합니다.
</div>
</details>

<details>
<summary><strong>사용자 모드와 커널 모드의 차이점에 대해 설명해주세요.</strong></summary>
<div markdown="1">
<br>
사용자 모드는 • 응용프로그램의 실행을 시작할 때 설정되는 CPU의 모드입니다. 사용자 공간의 메모리만 액세스가 가능하고, 커널 공간의 메모리는 접근할 수 없습니다. 만약 커널 공간의 메모리 번지에 접근하면 시스템에서는 예외를 발생시켜 사용자 프로그램을 종료시킵니다. 반면에 커널 모드는 CPU의 모든 메모리 공간을 액세스할 수 있습니다. 따라서 특권 명령어를 통해 어떤 하드웨어도 접근하고 제어할 수 있습니다. 시스템 호출이나 인터럽트가 발생했을 때 사용자 모드에서 커널 모드로 전환이 일어납니다.
</div>
</details>
    
<details>
<summary><strong>선택정렬에 대해 설명해주세요</strong></summary>
<div markdown="1">
<br>
선택정렬이란 제자리 정렬 알고리즘의 하나입니다. 주어진 리스트에서 최소값을 찾아서, 그 값을 맨 첫번째의 값과 교체합니다. 그러면 배열의 맨 앞 요소는 최소값이 됩니다. 그 다음 회차에서는 확정된 정렬을 제외한 나머지 원소 배열에서 최소값을 찾고 그 값을 다시 확정된 정렬을 제외한 나머지 원소 배열의 맨 앞 원소와 교환하는 방식을 반복하며 정렬합니다. 알고리즘이 단순하지만 시간복잡도가 O(n^2)로 비효율적이라는 단점이 있습니다.
</div>
</details>

<details>
<summary><strong>팩토리 패턴은 무엇인가요?</strong></summary>
<div markdown="1">
<br>
객체를 직접 생성하지 않고, 자식 클래스에서 어떤 객체를 생성할 지 결정하도록 위임하는 생성 디자인 패턴입니다. 객체 생성 코드를 별도의 공장 클래스로 분리하여 캡슐화하기때문에 SOLID 원칙 중, 단일 책임 원칙과 개방-폐쇄 원칙을 준수합니다. 그러나 각 Product 구현체가 늘어날 때마다 팩토리 클래스가 증가하여 서브 클래스 수가 많아집니다.
</div>
</details>

<br>
<br>


# 받은 피드백 & 재답변
### DATABASE

**RDBMS(SQL)와 NoSQL은 어느 경우에 적합한가요?**

SQL : 데이터 구조가 명확한 자료를 다루고, 중복 값을 배제하고 싶을 때 적합하다.

NoSQL : DB를 구축하는 것이 빠르기 때문에 프로토타입으로 생성하기에 유리. json형태를 가지고있다.

→ json 파일이 아니라 **collection** 파일

→ 중복값을 배제한다는 키워드보다는 **엄격한 schema 관계** 키워드 말하기!!


> SQL은 엄격한 스키마의 특징을 갖기 때문에 데이터 구조가 명확한 자료를 다루기에 적합합니다. 또한 데이터베이스의 ACID 성질을 준수해야할 때 사용합니다. 반면에 NoSQL은 정확한 데이터 구조를 알 수 없거나 변경될 수 있는 경우 적합합니다. 스키마를 구조화 할 필요가 없기 때문에 프로토타입을 출시해야 하는 경우에 유리합니다.

<br>

### Design Pattern

**싱글톤 패턴의 문제점을 1가지 대답하시오**

1번째 시도 : static으로 구현이 되어있어서 각 프로세스마다 하나의 인스턴스를 갖게 되기 때문에, 만약에 각 프로세스,or 스레드 마다 다른 객체를 사용해야 할 경우에 적합하지 않다.

프로세스 속에

2번째 시도 : 전체 프로그램에서 생성된 ststic객체를 공유해서 사용 모듈간 의존성이 높습니다. 또한 SOLID원칙을 위배하게 됩니다.

> 싱글톤 패턴은 프로그램에서 객체의 인스턴스가 1개로, static으로 생성합니다. 따라서 여러 모듈이 공유하기 때문에 모듈간 의존성이 높아지게 됩니다. 또한 하나의 인스턴스가 많은 일을 하게 되어 여러 책임을 지게 되고, 많은 데이터를 공유시키게 됩니다. 또한 클라이언트가 인터페이스같은 추상화가 아니라 구체 클래스에 의존하게 됩니다. 따라서 SOLID 원칙에 위배된다는 문제점이 있습니다.

<br>

### Network

**OSI 7계층에서 계층을 나눈 이유가 무엇인지 설명**

각 계층을 분리함으로써 프로그램이 동작하는 기능과 역할을 분리할 수 있어서 문제점이 발생했을 때 더 쉽게 해당 문제를 발견하고 해결할 수 있습니다.

→ 중요 **keyword**: **표준, 단계적**

> 각 계층을 독립적으로 분리함으로써 통신이 일어나는 과정에서 기능과 역할을 분리할 수 있습니다. 통신이 일어나는 과정을 단계별로 파악할 수 있기 때문에, 문제가  발생했을 경우 어떤 계층이 문제인지 발견이 가능합니다. 따라서 해당 단계만 고쳐서 해결할 수 있어, 유지보수가 수월합니다. 또한 표준 규격을 통해 네트워크의 구성 요소를 표준화하기때문에 서로 다른 통신 장치와 상호 호환이 가능합니다.

<br>

### Computer Architecture

**캐시메모리란?**

1번째 시도 : 작동 속도가 빠른 것과 느린 것 간의 시간차를 해결하기 위해 만들어진 메모리.

2번째 시도 : 빠른 구동 속도를  시간지역성과 공간지역성을 사용해서 데이터 로딩에 빠른 속도를 위해 사용하는 메모리 방식

시간지역성이란 최근에 참조된 데이터들을 다시 사용할 가능성이 높은 것이고, 공간지역성이란 최근에 참조된 데이터들을 그 주변 메모리들을 캐시메모리에 적재하는 것이 캐시메모리

> 캐시 메모리는 상대적으로 속도가 빠른 메모리와 느린 메모리 간의 속도차에 따른 병목 현상을 해결하기 위해 만들어진 메모리입니다. CPU가 주기억장치에서 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 주기억장치가 아닌 캐시 메모리에서 먼저 가져오면서 속도를 향상시킵니다. 캐시 메모리는 캐시 지역성을 이용해서 메모리에서 데이터를 가져옵니다. 시간지역성이란 최근에 참조된 데이터들을 다시 사용할 가능성이 높은 것이고, 공간지역성이란 최근에 참조된 데이터와 인접한 메모리를 참조할 가능성이 높은 것을 의미합니다.

<br>

### Algorithm

**삽입정렬의 장점에 대해 설명해주세요**

→ 삽입정렬의 이동에 대한 의문점 생김 끝나고 정리

> 삽입 정렬은 배열의 모든 요소를 2번째 요소부터 이미 정렬된 앞쪽 배열과 차례대로 비교하여, 자신의 위치를 찾아 삽입하며 정렬하는 알고리즘입니다. 자료의 수가 적은 배열에 효율적입니다. 회차가 거듭될수록 탐색 범위가 넓어지기때문에 비교적 많은 레코드들이 이동한다는 단점이 있습니다. 시간복잡도는 O(n^2)입니다.

<br>

### Data Structure

**힙의 최대힙,최소힙에 대해 설명해주세요**

이진트리 형식을 가지고있습니다.

최대힙 : 부모노드>자식노드

최소힙 : 부모노드<자식노드

→ 완전이진트리 형식

→ 배열의 구조를 가지고 있다는 키워드도 기억하기

> 힙은 완전 이진 트리의 일종으로, 우선순위 큐를 위해 만들어진 자료구조입니다. 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안되었습니다. 힙의 종류에는 최대힙과 최소힙이 있습니다. 최대힙은 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같습니다. 반면에 최소힙은 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같습니다.

<br>

### OS

**인터럽트란 무엇인지 개념**

사용자모드에서 커널모드로 전환이 일어날때 발생한 문제를 처리하는 과정?

→ 인터럽트 정리하기!

> 인터럽트란 프로그램을 실행하는 도중에 예기지 않은 문제가 발생한 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에 알리는 것을 의미합니다. 하드웨어 인터럽트는 CPU 외부로부터 인터럽트 요구 신호에 의해 발생됩니다. 입출력, 정전/전원 인터럽트 등이 있습니다. 소프트웨어 인터럽트는 프로그램의 오류에 의해 발생하는 인터럽트입니다. 0으로 나누거나 오버플로우가 발생할 경우 프로그램 검사 인터럽트가 발생합니다. 여러 장치에서 인터럽트가 동시에 발생하거나, 인터럽트 서비스 루틴 수행 중 인터럽트가 발생한 경우 우선순위 판별이 필요합니다. 
