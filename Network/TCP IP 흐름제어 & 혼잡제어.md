# TCP/IP 흐름제어 & 혼잡제어
<br/>

## 목차

1. 흐름제어
2. 혼잡제어
3. 예상 면접질문

<br/>

## 흐름제어

<br/>

### 흐름제어란?

수신 측이 송신 측보다 데이터 처리 속도가 빠르면 문제가 없지만, 송신 측의 속도가 빠를 경우 문제가 생긴다. 수신 측에서 제한된 저장 용량을 초과한 이후에 도착하는 패킷은 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송이 발생하게 된다.

흐름 제어는 위와 같이 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법이다.
<br/>

### Stop and Wait

<p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/263B7D4E5715ECEB32"
width="200px" height="220px"/></p>

매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법이다. 그러나 패킷을 하나씩 보내기 때문에 비효율적인 방법이다.
<br/>

### Sliding Window

수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어 기법이다.

- 윈도우 크기?
    - 윈도우는 메모리 버퍼의 일정 영역으로 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다.
    윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다.
- 동작 방식
    - 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송
        
        <p align="center"><img src="https://t1.daumcdn.net/cfile/tistory/253F7E485715ED5F27" width="600px" height="440px"/></p>

        
        - 최초로 수신자는 윈도우 사이즈를 7로 정한다.
        - 송신자는 수신자의 확인 응답(ACK)을 받기 전까지 데이터를 보낸다.
        - 수신자는 확인 응답(ACK)을 송신자에게 보내면, 슬라이딩 윈도우 사이즈을 충족할 수 있게끔 윈도우를 옆으로 옮긴다
        - 이후 데이터를 다 받을 때까지 위 과정을 반복한다.
<br/>

## 혼잡제어
<br/>

### 혼잡제어란?

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 
이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손신을 발생시키게 된다. 
따라서 이러한 네트워크의 혼잡을 피하기 우해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.
<br/>

### AIMD

- 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기를 1씩 증가시켜가며 전송하는 방법
- 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
- 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점이 있다.
<br/>

### Slow Start

- AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
- Slow Start는 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식이다.
<br/>
AIMD, Slow Start를 사용하면서 네트워크의 혼잡이 자주 발생하면 윈도우의 크기가 크게 감소하고 네트워크의 전송률이 매우 떨어진다. 따라서 TCP에는 패킷을 재전송하는 기법들이 존재한다. 이들 역시 혼잡제어 기법의 일종이다.
<br/>

### Fast Restransmit ****(빠른 재전송)****

- 패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 생길 수 있다. 이런 상황이 발생했을 때 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보낸다. 그리고 이런 중복 ACK를 3개 받으면 재전송이 이루어진다.
- 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지할 수 있다.
<br/>

### Fast ****Recovery (빠른 회복)****

- 빠른 회복은 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법이다. 이후에는 복구 및 증가 과정을 거치면서 혼잡 윈도우 크기를 조정한다. 이 방법을 적용하면 혼잡 상황을 한 번 겪고나서부터는 AIMD 방식으로 동작한다.
<br/>
실질적인 혼잡제어는 이 중 하나만으로 작동한다기보단, 상황에 따라 정책을 바꿔가며 제어한다. 예를 들면 처음에는 Slow Start를 사용하다가 혼잡 상태가 감지되면 AMID를 사용하는 방식이다. 이런 정책에는 Tahoe, Reno, New Reno, Cubic, Ealstic-TCP 등 여러가지가 존재한다.

<br/>
<br/>

## 예상 면접질문
<br/>

- TCP/IP 흐름제어, 혼잡제어의 차이가 무엇인지?
- 흐름제어 기법, 혼잡제어 기법에는 어떤 것이 존재하는지?
