# 클린코드 & 리팩토링 & 시큐어코딩

## 목차

1. 클린코드 & 리팩토링 & 시큐어코딩<br />
2. 코드 품질<br />
   2.1 코드의 품질이 소프트웨어 품질에 미치는 영향<br />
   2.2 코드 품질의 핵심 요소<br />
3. 다른 개발자와 코드 계약<br />

4. 가독성 높은 코드를 작성하자

## 1. 클린코드 & 리팩토링 & 시큐어코딩

✅ **클린코드**

클린코드란 가독성이 높은 코드를 말한다.

- 이해하기 쉬운 네이밍
- 오류가 없음
- 중복이 없음
- 의존성을 최대한 줄임(모듈화)
- 클래스 혹은 메소드가 한가지 일만 처리함

✅ **리팩토링**

리팩토링은 동작 자체는 그대로 두고, 내부의 코드를 정리하며 개선하는 것을 말한다. 일반적으로 프로젝트를 하면서 예쁜 코드를 한번에 작성하기란
쉽지 않다. 따라서 보통 프로젝트가 끝나고 향후의 유지보수를 위해 개선 해나가는 것을 리팩토링이라 한다. 리팩토링이 필요한 코드는 아래와 같다.

- 메소드 정리 : 그룹으로 묶을 수 있는 코드, 수식을 메소드로 변경함
- 객체 간의 기능 이동 : 메소드 기능에 따른 위치 변경, 클래스 기능을 명확히 구분
- 데이터 구성 : 캡슐화 기법을 적용해 데이터 접근 관리
- 조건문 단순화 : 조건 논리를 단순하고 명확하게 작성
- 메소드 호출 단순화 : 메소드 이름이나 목적이 맞지 않을 때 변경
- 클래스 및 메소드 일반화 : 동일 기능 메소드가 여러개 있으면 수퍼클래스로 이동

#

> 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것이 목적

✅ **시큐어코딩**

**소프트웨어 개발 보안** 이라고도 부른다. 소프트웨어를 개발하면서 개발자의 실수, 논리적 오류등 보안 취약점을 배제하기 위한 코딩 기법이다. 보안 취약점을 악용한 해킹 등을 안전하게 방어하는 방법.

보안 약점을 노려 발생하는 사고 사례들)

- SQL 인젝션 취약점으로 개인유출 사고 발생
- URL 파라미터 조작 개인정보 노출
- 무작위 대입공격 기프트카드 정보 유출

❌ 안전하지 않은 코드

```sql
String query "SELECT * FROM users WHERE userid = '" + userid + "'" + "AND password = '" + password + "'";

Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(query);
```

⭕️ 안전한 코드

```sql
String query "SELECT * FROM users WHERE userid = ? + "AND password = ?";

PrepareStatement stmt = connection.prepareStatement(query);
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

적절한 검증 작업이 수행되어야 안전하다고 한다.

## 2. 코드 품질

### 2.1 코드의 품질이 소프트웨어 품질에 미치는 영향

고품질의 코드는 일반적으로 더 신뢰할 수 있고, 유지보수가 쉬우며 버그가 적은 소프트웨어를 생산한다.
코드의 품질이 소프트웨어의 품질에 미치는 영향은 아래와 같다.

<center>

![image](https://github.com/Jiyun-Parkk/dev-blog/assets/72537762/e065736b-4d9e-4d80-8070-dff77476ff46)

</center>
<figcaption>출처: Goodcode Badcode</figcaption>

### 2.2 코드 품질의 핵심 요소

✅ 코드는 작동해야 한다

✅ 코드는 작동이 멈추면 안된다

현재는 잘 돌아가지만 미래에 어떤 변경이 있을 경우 제대로 동작하지 않는다면 유용한 코드가 아니다.

✅ 코드는 변경된 요구 사항에 적응할 수 있어야 한다

한번 작성되고 다시는 수정되지 않는 코드는 거의 없다. 다양 요구사항 및 환경에서 적응하기 위해서는 앞으로 어떠한 변경사항이 있을지에 대해 예측하고 모든 작재적 변화를 지원하는 코드를 설계하기 위해 노력 해야 한다.

✅ 코드는 이미 존재하는 기능을 중복 구현해서는 안된다

이미 있는 코드를 다시 작성하지 않는 다는 것은, 버그 가능성을 줄이고 시간과 노력을 절약할 수 있다. 만약 어떤 문제를 해결하기 위해 자신이 코드를 구현했다면, 다른 개발자들이 재사용하기 쉽게 구성해야 한다.

✅ 코드는 읽기 쉬워햐 한다.

협업하는 과정에서 읽기 어려운 코드는, 암호와 같다.

✅ 코드는 예측 가능해야 한다.

가장 흔한 예로 변수 이름을 생각할 수 있을 것 같다. 어떤 변수의 이름이 만약 `go`라고 할때 어떤 `go`인지는 만든 사람 말고는 알 수가 없다. 심지어 오래지나면 본인도 잊을 수 있다.

✅ 코드를 오용하기 어렵게 만들라

TV 뒷면을 보면 여러개의 소켓이 있는데 각 소켓의 모양은 다르다. 예를 들어 전원 소켓과 HDMI의 소켓은 확연히 다르다. 그런데 만약 이 소켓이 모두 동일한 모양이라면 실수로 잘못된 소켓에 꽂게 될 것이다. 코드도 마찬가지로 잘못된 데이터가 입력됨으로서 개발자가 원치 않는 결과를 내뱉으면 안된다.

✅ 코드를 모듈화 하라

모듈화는 개체나 시스템의 구성 요소가 독립적으로 교홚되거나 교체 될 수 있음을 의미한다. 코드를 외부에 의존하지 않고 실행 할 수 있는 모듈로 나누는 것이 이로울 때가 많다. 예를 들어 조립식 로봇과 봉제 인형 장난감이 있다고 가정하자. 조립식 로봇의 어느 한 부분을 고치고 싶다면 그 부분에 대해서만 따로 수정을 하면 된다. 그러다 만약 이전으로 돌아가고 싶다면 다시 원래 부품을 끼워 넣으면 된다. 하지만 봉제 인형은 한부분을 수정하려면 처음부터 다시 만들어야 한다.

모듈화 시스템의 주요 특징은 인터페이스가 잘 정의되어 있어서, 서로 다른 구성 요소 간 상호작용하는 지점이 최소화 된다는 것이다.

✅ 테스트가 용이한 코드를 작성하고 제대로 테스트하자

만약 테스트가 실해하면 변경된 코드를 코드베이스에 병합하는 것을 막는다. 소프트웨어 시스템과 코드베이스틑 너무 크고 복잡해서 한 사람이 모든 세부사항을 알 수 없고 사람은 실수 하는 존재이기 때문에 소프트웨어 개발에서 테스트는 정말 중요한 요소다.

> 테스트는 실제 코드를 돌려보고, 모든 것이 정상적으로 작동하는지 확인, 그리고 이것을 자동화 하기 위해 노력 한다.

#### 👉 단위 테스트 (unit test)

일반적으로 개별 함수나 클래스와 같은 작은 단위의 코드를 테스트

#### 👉 통합 테스트 (integration test)

시스템은 일반적으로 여러 구성 요소, 모듈, 하위 시스템으로 구성되는데 이런 것을 함께 연결하는 과정을 통합이라고 한다. 통합 테스트를 통해 이런 여러 구성요소들이 잘 작동하는지 테스트한다.

#### 👉 종단간 테스트 (end-to-end test e2e)

처음부터 끝까지 전체 소프트웨어 시스템에서 작동의 흐름을 테스트 한다. 예를 들어 쇼핑몰이라면 브라우저를 구동하고 사용자가 구매를 완료하는 데까지 진행 할 수 있는 과정을 테스트 하는 것을 e2e 테스트라고 한다.

```text
테스트 중심 개발(Test Driven Development)
개발 전에 테스트 코드부터 작성하는 것이 TDD라고 한다.
```

## 3. 다른 개발자와 코드 계약

코드를 작성할 때 아래의 세가지 사항에 대해 염두해야 한다.

✅ 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다.

✅ 다른 개발자는 무의식 중에 여러분의 코드를 망가뜨릴 수 있다.

✅ 시간이 지나면 자신의 코드를 기억하지 못한다.

`내 코드의 사용법을 알고 싶으면 코드 안에서 어떻게 구현됐는지 읽어보던가`라는 자세는 상황을 악화 시킨다. 협업시에는 한 코드가 또 다른 개발자의 코드에 의존하고 있기 때문에, 구현 세부 사항을 읽어보도록 두는것은 좋지 않다.

### 💡 코드 계약

`계약에 의한 프로그래밍 programming by contract`, `계약에 의한 디자인 design by contract`라는 것은 서로 다른 코드 간의 상호작용을 마치 계약처럼 생각하는 것이다. 코드 계약에 대한 용어는 세가지 범주로 나눌 수 있다.

- 선결조건(precondition): 코드를 호출하기 전에 사실이어야 하는 것. 예를 들어 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지

- 사후 조건(postcondition): 코드가 호출된 후에 사실이어야 하는 것. 예를 들어 시스템이 새로운 상태에 높인다던지 반환되는 값과 같은 상황

- 불변 사항(invariant): 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

코드 계약에는 `명확한 부분`과, `세부 조항`이 있다.

- 명확한 부분

> `Person`이라는 이름의 클래스이다. 따라서 이 클래스는 사람을 만드는 클래스다. `returnName`함수는 이름을 반환하는 함수 일 것이다.

- 세부조항

> 아래 코드에서 모든 주석이 세부조항 이다.

```java
class Person {
    // 이 함수를 사용해 사람 인스턴스가 만들어지기 전까지 어떤 함수도 호출해선 안된다.
    Person() {
        //...
    }

    // 이 함수는 다른 함수 호출 이전에 호출해야 한다
    void init() {
        //...
    }

    // 만든 사람 인스턴스의 이름을 반환한다

    static String returnName() {
        //...
    }
}
```

그런데 사실 위와 같은 주석 설명이나 프로그램의 문서화도 중요하고 좋지만, 업데이트가 잘 안될 가능성이 높고 잘 안읽을 가능성 또한 높다. 따라서 그렇게 추천되는 방법은 아니다. 다른 개발자가 코드를 올바르게 사용하기 위해 세부조항에 의존하기 보다, 처음부터 불가능하게 만드는 것이 좋다.

## 4. 가독성 높은 코드를 작성하자

### 💡 네이밍 컨벤션

✅ 기본적으로 영어 표기법을 준수한다.

| 종류         | 표기법        | 이유                                                                                                 | 예시                  |
| ------------ | ------------- | ---------------------------------------------------------------------------------------------------- | --------------------- |
| 클래스       | 파스칼 표기법 | 클래스는 프로그래밍에서 가장 주요하고 높은 위치에 있고 고유 명사처럼 특정된다                        | Person                |
| 변수, 함수   | 카멜 표기법   | 형용사나 동사로 시작하는 함수, 변수는 첫글자를 소문자를 쓴다                                         | getName               |
| 상수         | 모두 대문자   | 모든 글자를 대문자로 쓰고, 언더스코어로 연결한다                                                     | SCORE_COMPUTER        |
| 패키지, 모듈 | 모두 소문자   | 클래스나 함수보다 더 높은 위치이지만, 패키지 자체의 중요도가 낮다고 판단하여 모두 소문자로 표기 한다 | package baejoonsilver |
| css          | BEM           | 언더스코어 두개(대상의 요소나 부분), 하이픈(대상의 요소나 상태 속성)                                 | header\_\_h1-title    |

[네이밍 표기법](https://heytech.tistory.com/294)

[BEM 표기법](https://nykim.work/15)

> react나 vue를 사용하는 경우 class명이 고유화 되기 때문에, css 표기법을 신경 쓰지 않는 곳도 있다. 회사의 개발 문화에 따라 다르다.

### 💡 좋은 이름의 기준

👉 변수 이름이 길면 안좋다?

요즘에는 IDE에서 변수의 이름 검색이 잘되기 때문에 긴 것은 문제되지 않는다. 길이보다는 검색이 잘되고 주석 없이도 이해 할 수 있는 것이 좋다.

❌ 나쁜예

```javascript
getName(); // 사용자가 인풋에 입력한 이름 텍스트를 가져온다
```

⭕️ 좋은예

```javascript
getUserNameFromInput();
```

👉 복수형

만약 여러개의 과일 배열을 담는 변수라고 가정해보자.

❌ 나쁜예

```javascript
const fruits = [...]
```

⭕️ 좋은예

```javascript
const listOfFruits = [...]
```

👉 약어

보편성을 기준으로 쓴다.

ex) 예시

- temp : 임시 (보통 데이터 swap시 많이 사용)
- param : 파라미터
- args : arguments
- btn : button
- txt : text

[변수명 짓는 사이트](https://www.curioustore.com/)

👉 순서

중요한 단어를 앞에 쓴다

👉 좋은 이름의 다섯가지 원칙

- easy to Search : 검색하기 쉽고
- easy to Mix : 조합하기 쉽고
- easy to Agree : 수긍하기 쉽고
- easy to Remember : 기억하기 쉽고
- easy to Type : 입력하기 쉽고

### 💡 주석문의 적절한 사용

- 코드가 `무엇`을 하는지 설명
- 코드가 `왜` 그 일을 하는지 설명
- 사용 지침 등 기타 정보 제공

한가지 중요한 점은 장황한 주석문보다는 `가독성 높은 코드`가 우선순위 이다. 가독성 높은 코드로 충분히 설명이 되는 것 외의 것을 주석으로 작성해야 한다. 코드가 `왜` 그 일을 수행하는지에 대한 일은, 코드 자체로는 어렵기 때문이다.

- 제품 또는 비즈니스 의사 결정
- 이상하고 명확하지 않은 버그에 대한 해결책
- 의존하는 코드의 예상을 벗어나는 동작에 대처

```java
/**
 * 스트리밍 서비스의 유저에 대한 자세한 사항을 갖는다
 *
 * 이 클래스는 데이터베이스에 직접 연결하지 않는다.
 * 대신 메모리에 저장된 값으로 생선된다.
 */

class User {}
```

위 예시 코드처럼 주석은 코드만으로 전달 할 수 없는 세부 사항을 설명하거나 코드가 큰 단위에서 하는 일을 요약하는 데 유용하다.
단점으로는 앞서 말한 것처럼, 문서도 유지 보수가 필요한데 제때 업데이트가 되지 않으면 코드와 맞지 않을 뿐더러 코드가 지저분 해질 수 있다.

### 💡 간결하다고 다 좋은 코드가 아니다

간결하더라도 이해하기 어려운 코드들이 있다. 예를 들면 코드는 한줄이지만 삼항식이 여러개 있으면 이해하기가 힘들다

❌ 나쁜예

```javascript
let resultText = isCheck
  ? isDark
    ? 'dark'
    : 'light'
  : isComplete
  ? '완료'
  : '실패';
```

⭕️ 좋은예

```javascript
let resultText = '';

if (isCheck) {
  resultText = isDark ? 'dark' : 'light';
} else {
  resultText = isComplete ? '완료' : '실패';
}
```

### 💡 스타일 가이드를 채택하고 따르라

- 언어의 특정 기능 사용
- 코드의 들여쓰기
- 패키지 및 디렉터리 구조화
- 코드 문서화 사용법

팀에서 만약 가이드가 없다면, 이미 공개되고 제안된 것들이 많다.

[구글 스타일 가이드 레포지토리](https://github.com/google/styleguide)

### 💡 깊이 중첩된 코드를 피하라

보통 함수는 하나의 일만 수행하는 것이 좋은데, 중첩이 깊어지면 그 함수가 너무 많은 일을 수행하고 있다는 신호다.
따라서 중첩된 코드를 피하기 위해서는 작은 함수로 분리하는 것이 좋다.

📚 참고: 좋은코드 나쁜코드 - 제이펍

[참고: 변수명을 잘 짓기 위한 몸부림](https://brunch.co.kr/@wapj2000/29)

[참고: 변수명 잘짓기](https://velog.io/@humonnom/%EB%84%A4%EC%9D%B4%EB%B0%8D-%EC%BB%A8%EB%B2%A4%EC%85%98%EA%B3%BC-%EB%B3%80%EC%88%98%EC%9D%B4%EB%A6%84-%EC%A7%93%EA%B8%B0)
