# 고정소수점 & 부동소수점

## 목차

1. 컴퓨터가 수를 표현하는 방식
2. 고정소수점이란?
3. 부동소수점이란?
4. 면접질문

## 1. 컴퓨터가 수를 표현하는 방식

컴퓨터는 0과 1의 조합으로 이루어진 비트만을 저장하고 연산할 수 있다. 따라서 컴퓨터에 저장되는 모든 것은 이진수로 저장된다.

### 💡 참고: 10진수 이진수로 바꾸기

10진수를 2진수로 바꾸기 위해서는 1이 될 떄까지 계속 2로 나눠가면서 나머지를 구하고, 밑에서부터 거꾸로 이어붙이면 된다.

<div align="center">

![image](https://github.com/woorifisa-member/2023-CS-Study/assets/72537762/71fb9034-1b96-43d8-8c03-630f2702f6b5)

</div>

### 실수의 표현 방식

컴퓨터에서 실수를 표현하는 방법은 정수에 비해서 더 복잡하다. 왜냐하면 정수부와 소수부를 따로 이진수로 변환해야 하기 때문이다. 따라서 실수를 표현하기 위해서 다음과 같은 방식이 사용된다.

1. 고정 소수점
2. 부동 소수점

### 💡 참고: 소수부 이진수로 바꾸기

정수 1이 나올때까지 2로 곱하고, 앞에 정수부만 따서 이진수로 만든다.

```text
0.75 * 2 = 1.5
0.5 * 2 = 1
```

=> 0.75(10) = 0.11(2)

## 2. 고정 소수점이란?

실수는 보통 정수부와 소수부로 나눌 수 있다. 실수를 표현하는 가장 간단한 방식은 소수부 자릿수를 정하여 `고정된 자릿수의 소수를 표현`하는 것이다.

따라서 고정소수점 방식은 정수를 표현하는 비트와 소수를 표현하는 비트수를 미리 정하고 해당 비트만 활용해서 실수를 표현하는 것을 의미한다.

고정 소수점은 아래와 같은 특징이 있다.

<32비트 기준>

- 처음 1비트는 부호를 나타낸다. 양수는 0, 음수는 1
- 다음 15비트는 정수부를 나타낸다.
- 다음 16비트는 소수부를 나타낸다.
- 정수부와 소수부의 경계를 소수점의 위치라고 생각하고 2진수로 변환된 수를 그대로 넣으면 된다.
- 남는 자리는 0으로 채운다.

`7.625`를 고정소수점방식으로 변환하면 아래와 같다.

- 양수이므로 부호는 0
- 7의 이진수는 111
- 0.625의 이진수는 101
- 나머지는 0으로 채운다.

<div align="center">

![image](https://github.com/woorifisa-member/2023-CS-Study/assets/72537762/edc82b88-8420-4250-a517-47ea92e6fce6)

![image](https://github.com/woorifisa-member/2023-CS-Study/assets/72537762/1f10760d-2303-4193-8b4b-20f9df90a84a)

</div>

### 고정소수점의 장점

- 표현 방식이 단순해서 속도가 빠르다.

### 고정소수점의 단점

- 비트가 고정되어 있기 때문에 큰 실수를 표현하기 어렵다.

## 3. 부동 소수점

부동 소수점의 부동은 `부유하다(float)`의 의미를 가지고 있다. 따라서 소수점이 옮겨다니는 방식의 실수 표현법이라고 이해하면 된다.

부동 소수점 방식은 고정 소수점 표현방식과 비트를 사용하는 체계가 다르다. 부동 소수점을 표현하는 체계는 여러가지가 있는데 일반적으로 널리 쓰이는 표준은 IEEE 754이다. IEEE754에 따르면 실수를 다음과 같이 부동 소수점 방식으로 표현 할 수 있다.

- 2진수를 정규화 한다.
- 처음 1비트는 부호를 나타낸다. 양수는 0 음수는 1
- 다음 8비트는 지수부를 나타낸다.
- 다음 23비트는 가수부를 나타낸다.

> 정규화: 정규화라는 것은 2진수를 1.xxx... \* 2^n의 형태로 나타내는 것을 말한다.

![image](https://github.com/woorifisa-member/2023-CS-Study/assets/72537762/21a8b809-4c81-45e3-9ef3-da36b55a3d05)

```text
(-1)^S * M * B^E
```

- S: 부호(양수, 정수)
- M: 가수(mantissa)
- B: 기저(bias) - 기초가 되는
- E: 지수(exponent)

예를 들어 `1.234 * 10^12`의 경우,

양수이므로 S = 0, M = 1.234, B = 10, E = 12가 된다.

그런데 컴퓨터는 기본적으로 2진법이므로 부동소수점에서 Bias(기저)는 2로 고정된다.

### 부동소수점 계산법

7.625를 부동소수점으로 표현해보면 아래와 같다.

#### 1. 2진수 변환

```text
111.101
```

#### 2. 정규화

소수점을 첫번째 자리로 옮긴다. 두번 옮겼으므로 2의 2승을 곱해준다.

```text
1.11101 * 2^2
```

#### 3. 가수부

가수부는 정규화한 값에서 소수점 뒤 값이다.

```
1.11101 * 2^2
가수부: 11101
```

#### 4. 지수표현하기(초과표기법)

지수값을 표현하기 위해 n비트가 할당되면, 2개의 숫자 `2^n-1`,`2^n-1 - 1`를 매직넘버로 지정한다. 예를 들어서 n이 8비트면 128(2^8-1), 127(2^8-1 -1)이 매직넘버가 되며, 여기서는 각각을 구분하기 위해 초과\_128, 초과\_127과 같이 나타낸다. 사실 두 매직넘버 중 어떤 것을 사용할 것인가는 사용자의 결정이 아닌, 시스템에 의해서 미리 정해져 있다.

예를 들어서, 10진수로 주어진 지수값 -32를 8비트 초과표기법으로 표현하기 위해서는 주어진 수에 매직넘버를 더한 결과를 2진수로 변환해서 8비트 지수 부분에 채우면 된다.

```
-32 + 127 = 95
95(10) = 01011111(2)
```

반대로 지수 부분에 저장된 2진수로부터 지수값을 얻어 내려면 저장된 2진수에 대해서 매직넘버를 빼면 된다.

```
95(10) = 01011111(2)
95 - 127 = 32
```

다시 예제로 돌아가서 초과표기법으로 지수부를 표현하면 아래와 같다.

```
1.11101 * 2^2
2 + 127 = 129
129(10) = 10000001(2)
```

계산값을 종합해보면 아래와 같은 결과가 나온다.

<div align="center">

![image](https://github.com/woorifisa-member/2023-CS-Study/assets/72537762/e06ac506-dcff-476f-85d6-2e2378465c81)
3-630f2702f6b5)

</div>

### 부동소수점의 장점

부동소수점은 고정소수점에 비해 더 큰 숫자를 표현할 수 있다.

### 부동소수점의 단점

실수 연산이 부정확할 수 있다. 예를 들어서 0.3을 2진수로 변환하면 무한 반복이 된다.
따라서 컴퓨터가 실수 부분을 표현할 수 있는 비트수를 다 써버리게 되어서 근사치로 표현되는 것이다.

아래 자바 코드를 보면 0.1을 1000번 더했으니 100이 되어야 하지만 실제로는 100.09999999999859가 출력 된다. 이처럼 컴퓨터가 실수로 수행하는 모든 연산에는 언제나 작은 오차가 존재한다. 자바 뿐만 아니라 모든 프로그래밍 언어에서 발생하는 기본적인 문제이다.

```java
double num = 0.1;
for(int i = 0; i < 1000; i++) {
    num += 0.1;
}
System.out.print(num); // 100.09999999999859
```

## 4. 면접질문

- 부동소수점에 대해서 말해주세요

[참고 - 실수의 표현](http://www.tcpschool.com/java/java_datatype_floatingPointNumber)

[참고 - 고정소수점과 부동소수점](https://gguguk.github.io/posts/fixed_point_and_floating_point/)

[참고- 고정소수점과 부동소수점2](https://woo-dev.tistory.com/93)
